/*
 * Palette APIs - 3.4
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.spectrocloud.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.spectrocloud.client.model.V1CloudType;
import com.spectrocloud.client.model.V1ObjectReference;
import com.spectrocloud.client.model.V1PackRef;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * ClusterProfileTemplate contains details of a clusterprofile definition
 */
@Schema(description = "ClusterProfileTemplate contains details of a clusterprofile definition")


public class V1ClusterProfileTemplate {
  @SerializedName("cloudType")
  private V1CloudType cloudType = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("packServerRefs")
  private List<V1ObjectReference> packServerRefs = null;

  @SerializedName("packServerSecret")
  private String packServerSecret = null;

  @SerializedName("packs")
  private List<V1PackRef> packs = null;

  @SerializedName("profileVersion")
  private String profileVersion = null;

  @SerializedName("type")
  private String type = null;

  @SerializedName("uid")
  private String uid = null;

  @SerializedName("version")
  private Integer version = null;

  public V1ClusterProfileTemplate cloudType(V1CloudType cloudType) {
    this.cloudType = cloudType;
    return this;
  }

   /**
   * Get cloudType
   * @return cloudType
  **/
  @Schema(description = "")
  public V1CloudType getCloudType() {
    return cloudType;
  }

  public void setCloudType(V1CloudType cloudType) {
    this.cloudType = cloudType;
  }

  public V1ClusterProfileTemplate name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Get name
   * @return name
  **/
  @Schema(description = "")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public V1ClusterProfileTemplate packServerRefs(List<V1ObjectReference> packServerRefs) {
    this.packServerRefs = packServerRefs;
    return this;
  }

  public V1ClusterProfileTemplate addPackServerRefsItem(V1ObjectReference packServerRefsItem) {
    if (this.packServerRefs == null) {
      this.packServerRefs = new ArrayList<V1ObjectReference>();
    }
    this.packServerRefs.add(packServerRefsItem);
    return this;
  }

   /**
   * PackServerRefs is only used on Hubble side it is reference to pack registry servers which PackRef belongs to in hubble, pack server is a top level object, so use a reference to point to it packs within a clusterprofile can come from different pack servers, so this is an array
   * @return packServerRefs
  **/
  @Schema(description = "PackServerRefs is only used on Hubble side it is reference to pack registry servers which PackRef belongs to in hubble, pack server is a top level object, so use a reference to point to it packs within a clusterprofile can come from different pack servers, so this is an array")
  public List<V1ObjectReference> getPackServerRefs() {
    return packServerRefs;
  }

  public void setPackServerRefs(List<V1ObjectReference> packServerRefs) {
    this.packServerRefs = packServerRefs;
  }

  public V1ClusterProfileTemplate packServerSecret(String packServerSecret) {
    this.packServerSecret = packServerSecret;
    return this;
  }

   /**
   * This secret is used only on Palette side use case is similar  to k8s image pull secret this single secret internally should contains all the pack servers in PackServerRefs if empty, means no credential is needed to access the pack server For spectro saas, Ally will set this field before pass to palette
   * @return packServerSecret
  **/
  @Schema(description = "This secret is used only on Palette side use case is similar  to k8s image pull secret this single secret internally should contains all the pack servers in PackServerRefs if empty, means no credential is needed to access the pack server For spectro saas, Ally will set this field before pass to palette")
  public String getPackServerSecret() {
    return packServerSecret;
  }

  public void setPackServerSecret(String packServerSecret) {
    this.packServerSecret = packServerSecret;
  }

  public V1ClusterProfileTemplate packs(List<V1PackRef> packs) {
    this.packs = packs;
    return this;
  }

  public V1ClusterProfileTemplate addPacksItem(V1PackRef packsItem) {
    if (this.packs == null) {
      this.packs = new ArrayList<V1PackRef>();
    }
    this.packs.add(packsItem);
    return this;
  }

   /**
   * Packs definitions here are final definitions. If ClonedFrom and ParamsOverwrite is present, then Packs are the final merge result of ClonedFrom and ParamsOverwrite So orchestration engine will just take the Packs and do the work, no need to worry about parameters merge
   * @return packs
  **/
  @Schema(description = "Packs definitions here are final definitions. If ClonedFrom and ParamsOverwrite is present, then Packs are the final merge result of ClonedFrom and ParamsOverwrite So orchestration engine will just take the Packs and do the work, no need to worry about parameters merge")
  public List<V1PackRef> getPacks() {
    return packs;
  }

  public void setPacks(List<V1PackRef> packs) {
    this.packs = packs;
  }

  public V1ClusterProfileTemplate profileVersion(String profileVersion) {
    this.profileVersion = profileVersion;
    return this;
  }

   /**
   * version start from 1.0.0, matching the index of ClusterProfileSpec.Versions[] will be used by clusterSpec to identify which version is applied to the cluster
   * @return profileVersion
  **/
  @Schema(description = "version start from 1.0.0, matching the index of ClusterProfileSpec.Versions[] will be used by clusterSpec to identify which version is applied to the cluster")
  public String getProfileVersion() {
    return profileVersion;
  }

  public void setProfileVersion(String profileVersion) {
    this.profileVersion = profileVersion;
  }

  public V1ClusterProfileTemplate type(String type) {
    this.type = type;
    return this;
  }

   /**
   * Get type
   * @return type
  **/
  @Schema(description = "")
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  public V1ClusterProfileTemplate uid(String uid) {
    this.uid = uid;
    return this;
  }

   /**
   * Get uid
   * @return uid
  **/
  @Schema(description = "")
  public String getUid() {
    return uid;
  }

  public void setUid(String uid) {
    this.uid = uid;
  }

  public V1ClusterProfileTemplate version(Integer version) {
    this.version = version;
    return this;
  }

   /**
   * Deprecated. Use profileVersion
   * @return version
  **/
  @Schema(description = "Deprecated. Use profileVersion")
  public Integer getVersion() {
    return version;
  }

  public void setVersion(Integer version) {
    this.version = version;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1ClusterProfileTemplate v1ClusterProfileTemplate = (V1ClusterProfileTemplate) o;
    return Objects.equals(this.cloudType, v1ClusterProfileTemplate.cloudType) &&
        Objects.equals(this.name, v1ClusterProfileTemplate.name) &&
        Objects.equals(this.packServerRefs, v1ClusterProfileTemplate.packServerRefs) &&
        Objects.equals(this.packServerSecret, v1ClusterProfileTemplate.packServerSecret) &&
        Objects.equals(this.packs, v1ClusterProfileTemplate.packs) &&
        Objects.equals(this.profileVersion, v1ClusterProfileTemplate.profileVersion) &&
        Objects.equals(this.type, v1ClusterProfileTemplate.type) &&
        Objects.equals(this.uid, v1ClusterProfileTemplate.uid) &&
        Objects.equals(this.version, v1ClusterProfileTemplate.version);
  }

  @Override
  public int hashCode() {
    return Objects.hash(cloudType, name, packServerRefs, packServerSecret, packs, profileVersion, type, uid, version);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1ClusterProfileTemplate {\n");
    
    sb.append("    cloudType: ").append(toIndentedString(cloudType)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    packServerRefs: ").append(toIndentedString(packServerRefs)).append("\n");
    sb.append("    packServerSecret: ").append(toIndentedString(packServerSecret)).append("\n");
    sb.append("    packs: ").append(toIndentedString(packs)).append("\n");
    sb.append("    profileVersion: ").append(toIndentedString(profileVersion)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    uid: ").append(toIndentedString(uid)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
