/*
 * Palette APIs - 3.4
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.spectrocloud.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.spectrocloud.client.model.V1VmDHCPOptions;
import com.spectrocloud.client.model.V1VmInterfaceBridge;
import com.spectrocloud.client.model.V1VmInterfaceMacvtap;
import com.spectrocloud.client.model.V1VmInterfaceMasquerade;
import com.spectrocloud.client.model.V1VmInterfacePasst;
import com.spectrocloud.client.model.V1VmInterfaceSRIOV;
import com.spectrocloud.client.model.V1VmInterfaceSlirp;
import com.spectrocloud.client.model.V1VmPort;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * V1VmInterface
 */



public class V1VmInterface {
  @SerializedName("acpiIndex")
  private Integer acpiIndex = null;

  @SerializedName("bootOrder")
  private Integer bootOrder = null;

  @SerializedName("bridge")
  private V1VmInterfaceBridge bridge = null;

  @SerializedName("dhcpOptions")
  private V1VmDHCPOptions dhcpOptions = null;

  @SerializedName("macAddress")
  private String macAddress = null;

  @SerializedName("macvtap")
  private V1VmInterfaceMacvtap macvtap = null;

  @SerializedName("masquerade")
  private V1VmInterfaceMasquerade masquerade = null;

  @SerializedName("model")
  private String model = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("passt")
  private V1VmInterfacePasst passt = null;

  @SerializedName("pciAddress")
  private String pciAddress = null;

  @SerializedName("ports")
  private List<V1VmPort> ports = null;

  @SerializedName("slirp")
  private V1VmInterfaceSlirp slirp = null;

  @SerializedName("sriov")
  private V1VmInterfaceSRIOV sriov = null;

  @SerializedName("tag")
  private String tag = null;

  public V1VmInterface acpiIndex(Integer acpiIndex) {
    this.acpiIndex = acpiIndex;
    return this;
  }

   /**
   * If specified, the ACPI index is used to provide network interface device naming, that is stable across changes in PCI addresses assigned to the device. This value is required to be unique across all devices and be between 1 and (16*1024-1).
   * @return acpiIndex
  **/
  @Schema(description = "If specified, the ACPI index is used to provide network interface device naming, that is stable across changes in PCI addresses assigned to the device. This value is required to be unique across all devices and be between 1 and (16*1024-1).")
  public Integer getAcpiIndex() {
    return acpiIndex;
  }

  public void setAcpiIndex(Integer acpiIndex) {
    this.acpiIndex = acpiIndex;
  }

  public V1VmInterface bootOrder(Integer bootOrder) {
    this.bootOrder = bootOrder;
    return this;
  }

   /**
   * BootOrder is an integer value &gt; 0, used to determine ordering of boot devices. Lower values take precedence. Each interface or disk that has a boot order must have a unique value. Interfaces without a boot order are not tried.
   * @return bootOrder
  **/
  @Schema(description = "BootOrder is an integer value > 0, used to determine ordering of boot devices. Lower values take precedence. Each interface or disk that has a boot order must have a unique value. Interfaces without a boot order are not tried.")
  public Integer getBootOrder() {
    return bootOrder;
  }

  public void setBootOrder(Integer bootOrder) {
    this.bootOrder = bootOrder;
  }

  public V1VmInterface bridge(V1VmInterfaceBridge bridge) {
    this.bridge = bridge;
    return this;
  }

   /**
   * Get bridge
   * @return bridge
  **/
  @Schema(description = "")
  public V1VmInterfaceBridge getBridge() {
    return bridge;
  }

  public void setBridge(V1VmInterfaceBridge bridge) {
    this.bridge = bridge;
  }

  public V1VmInterface dhcpOptions(V1VmDHCPOptions dhcpOptions) {
    this.dhcpOptions = dhcpOptions;
    return this;
  }

   /**
   * Get dhcpOptions
   * @return dhcpOptions
  **/
  @Schema(description = "")
  public V1VmDHCPOptions getDhcpOptions() {
    return dhcpOptions;
  }

  public void setDhcpOptions(V1VmDHCPOptions dhcpOptions) {
    this.dhcpOptions = dhcpOptions;
  }

  public V1VmInterface macAddress(String macAddress) {
    this.macAddress = macAddress;
    return this;
  }

   /**
   * Interface MAC address. For example: de:ad:00:00:be:af or DE-AD-00-00-BE-AF.
   * @return macAddress
  **/
  @Schema(description = "Interface MAC address. For example: de:ad:00:00:be:af or DE-AD-00-00-BE-AF.")
  public String getMacAddress() {
    return macAddress;
  }

  public void setMacAddress(String macAddress) {
    this.macAddress = macAddress;
  }

  public V1VmInterface macvtap(V1VmInterfaceMacvtap macvtap) {
    this.macvtap = macvtap;
    return this;
  }

   /**
   * Get macvtap
   * @return macvtap
  **/
  @Schema(description = "")
  public V1VmInterfaceMacvtap getMacvtap() {
    return macvtap;
  }

  public void setMacvtap(V1VmInterfaceMacvtap macvtap) {
    this.macvtap = macvtap;
  }

  public V1VmInterface masquerade(V1VmInterfaceMasquerade masquerade) {
    this.masquerade = masquerade;
    return this;
  }

   /**
   * Get masquerade
   * @return masquerade
  **/
  @Schema(description = "")
  public V1VmInterfaceMasquerade getMasquerade() {
    return masquerade;
  }

  public void setMasquerade(V1VmInterfaceMasquerade masquerade) {
    this.masquerade = masquerade;
  }

  public V1VmInterface model(String model) {
    this.model = model;
    return this;
  }

   /**
   * Interface model. One of: e1000, e1000e, ne2k_pci, pcnet, rtl8139, virtio. Defaults to virtio.
   * @return model
  **/
  @Schema(description = "Interface model. One of: e1000, e1000e, ne2k_pci, pcnet, rtl8139, virtio. Defaults to virtio.")
  public String getModel() {
    return model;
  }

  public void setModel(String model) {
    this.model = model;
  }

  public V1VmInterface name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Logical name of the interface as well as a reference to the associated networks. Must match the Name of a Network.
   * @return name
  **/
  @Schema(required = true, description = "Logical name of the interface as well as a reference to the associated networks. Must match the Name of a Network.")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public V1VmInterface passt(V1VmInterfacePasst passt) {
    this.passt = passt;
    return this;
  }

   /**
   * Get passt
   * @return passt
  **/
  @Schema(description = "")
  public V1VmInterfacePasst getPasst() {
    return passt;
  }

  public void setPasst(V1VmInterfacePasst passt) {
    this.passt = passt;
  }

  public V1VmInterface pciAddress(String pciAddress) {
    this.pciAddress = pciAddress;
    return this;
  }

   /**
   * If specified, the virtual network interface will be placed on the guests pci address with the specified PCI address. For example: 0000:81:01.10
   * @return pciAddress
  **/
  @Schema(description = "If specified, the virtual network interface will be placed on the guests pci address with the specified PCI address. For example: 0000:81:01.10")
  public String getPciAddress() {
    return pciAddress;
  }

  public void setPciAddress(String pciAddress) {
    this.pciAddress = pciAddress;
  }

  public V1VmInterface ports(List<V1VmPort> ports) {
    this.ports = ports;
    return this;
  }

  public V1VmInterface addPortsItem(V1VmPort portsItem) {
    if (this.ports == null) {
      this.ports = new ArrayList<V1VmPort>();
    }
    this.ports.add(portsItem);
    return this;
  }

   /**
   * List of ports to be forwarded to the virtual machine.
   * @return ports
  **/
  @Schema(description = "List of ports to be forwarded to the virtual machine.")
  public List<V1VmPort> getPorts() {
    return ports;
  }

  public void setPorts(List<V1VmPort> ports) {
    this.ports = ports;
  }

  public V1VmInterface slirp(V1VmInterfaceSlirp slirp) {
    this.slirp = slirp;
    return this;
  }

   /**
   * Get slirp
   * @return slirp
  **/
  @Schema(description = "")
  public V1VmInterfaceSlirp getSlirp() {
    return slirp;
  }

  public void setSlirp(V1VmInterfaceSlirp slirp) {
    this.slirp = slirp;
  }

  public V1VmInterface sriov(V1VmInterfaceSRIOV sriov) {
    this.sriov = sriov;
    return this;
  }

   /**
   * Get sriov
   * @return sriov
  **/
  @Schema(description = "")
  public V1VmInterfaceSRIOV getSriov() {
    return sriov;
  }

  public void setSriov(V1VmInterfaceSRIOV sriov) {
    this.sriov = sriov;
  }

  public V1VmInterface tag(String tag) {
    this.tag = tag;
    return this;
  }

   /**
   * If specified, the virtual network interface address and its tag will be provided to the guest via config drive
   * @return tag
  **/
  @Schema(description = "If specified, the virtual network interface address and its tag will be provided to the guest via config drive")
  public String getTag() {
    return tag;
  }

  public void setTag(String tag) {
    this.tag = tag;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1VmInterface v1VmInterface = (V1VmInterface) o;
    return Objects.equals(this.acpiIndex, v1VmInterface.acpiIndex) &&
        Objects.equals(this.bootOrder, v1VmInterface.bootOrder) &&
        Objects.equals(this.bridge, v1VmInterface.bridge) &&
        Objects.equals(this.dhcpOptions, v1VmInterface.dhcpOptions) &&
        Objects.equals(this.macAddress, v1VmInterface.macAddress) &&
        Objects.equals(this.macvtap, v1VmInterface.macvtap) &&
        Objects.equals(this.masquerade, v1VmInterface.masquerade) &&
        Objects.equals(this.model, v1VmInterface.model) &&
        Objects.equals(this.name, v1VmInterface.name) &&
        Objects.equals(this.passt, v1VmInterface.passt) &&
        Objects.equals(this.pciAddress, v1VmInterface.pciAddress) &&
        Objects.equals(this.ports, v1VmInterface.ports) &&
        Objects.equals(this.slirp, v1VmInterface.slirp) &&
        Objects.equals(this.sriov, v1VmInterface.sriov) &&
        Objects.equals(this.tag, v1VmInterface.tag);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acpiIndex, bootOrder, bridge, dhcpOptions, macAddress, macvtap, masquerade, model, name, passt, pciAddress, ports, slirp, sriov, tag);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1VmInterface {\n");
    
    sb.append("    acpiIndex: ").append(toIndentedString(acpiIndex)).append("\n");
    sb.append("    bootOrder: ").append(toIndentedString(bootOrder)).append("\n");
    sb.append("    bridge: ").append(toIndentedString(bridge)).append("\n");
    sb.append("    dhcpOptions: ").append(toIndentedString(dhcpOptions)).append("\n");
    sb.append("    macAddress: ").append(toIndentedString(macAddress)).append("\n");
    sb.append("    macvtap: ").append(toIndentedString(macvtap)).append("\n");
    sb.append("    masquerade: ").append(toIndentedString(masquerade)).append("\n");
    sb.append("    model: ").append(toIndentedString(model)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    passt: ").append(toIndentedString(passt)).append("\n");
    sb.append("    pciAddress: ").append(toIndentedString(pciAddress)).append("\n");
    sb.append("    ports: ").append(toIndentedString(ports)).append("\n");
    sb.append("    slirp: ").append(toIndentedString(slirp)).append("\n");
    sb.append("    sriov: ").append(toIndentedString(sriov)).append("\n");
    sb.append("    tag: ").append(toIndentedString(tag)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
