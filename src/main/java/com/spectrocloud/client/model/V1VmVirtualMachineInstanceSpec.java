/*
 * Palette APIs - 3.4
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.spectrocloud.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.spectrocloud.client.model.V1VmAccessCredential;
import com.spectrocloud.client.model.V1VmAffinity;
import com.spectrocloud.client.model.V1VmDomainSpec;
import com.spectrocloud.client.model.V1VmNetwork;
import com.spectrocloud.client.model.V1VmPodDnsConfig;
import com.spectrocloud.client.model.V1VmProbe;
import com.spectrocloud.client.model.V1VmToleration;
import com.spectrocloud.client.model.V1VmTopologySpreadConstraint;
import com.spectrocloud.client.model.V1VmVolume;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * VirtualMachineInstanceSpec is a description of a VirtualMachineInstance.
 */
@Schema(description = "VirtualMachineInstanceSpec is a description of a VirtualMachineInstance.")


public class V1VmVirtualMachineInstanceSpec {
  @SerializedName("accessCredentials")
  private List<V1VmAccessCredential> accessCredentials = null;

  @SerializedName("affinity")
  private V1VmAffinity affinity = null;

  @SerializedName("dnsConfig")
  private V1VmPodDnsConfig dnsConfig = null;

  @SerializedName("dnsPolicy")
  private String dnsPolicy = null;

  @SerializedName("domain")
  private V1VmDomainSpec domain = null;

  @SerializedName("evictionStrategy")
  private String evictionStrategy = null;

  @SerializedName("hostname")
  private String hostname = null;

  @SerializedName("livenessProbe")
  private V1VmProbe livenessProbe = null;

  @SerializedName("networks")
  private List<V1VmNetwork> networks = null;

  @SerializedName("nodeSelector")
  private Map<String, String> nodeSelector = null;

  @SerializedName("priorityClassName")
  private String priorityClassName = null;

  @SerializedName("readinessProbe")
  private V1VmProbe readinessProbe = null;

  @SerializedName("schedulerName")
  private String schedulerName = null;

  @SerializedName("startStrategy")
  private String startStrategy = null;

  @SerializedName("subdomain")
  private String subdomain = null;

  @SerializedName("terminationGracePeriodSeconds")
  private Long terminationGracePeriodSeconds = null;

  @SerializedName("tolerations")
  private List<V1VmToleration> tolerations = null;

  @SerializedName("topologySpreadConstraints")
  private List<V1VmTopologySpreadConstraint> topologySpreadConstraints = null;

  @SerializedName("volumes")
  private List<V1VmVolume> volumes = null;

  public V1VmVirtualMachineInstanceSpec accessCredentials(List<V1VmAccessCredential> accessCredentials) {
    this.accessCredentials = accessCredentials;
    return this;
  }

  public V1VmVirtualMachineInstanceSpec addAccessCredentialsItem(V1VmAccessCredential accessCredentialsItem) {
    if (this.accessCredentials == null) {
      this.accessCredentials = new ArrayList<V1VmAccessCredential>();
    }
    this.accessCredentials.add(accessCredentialsItem);
    return this;
  }

   /**
   * Specifies a set of public keys to inject into the vm guest
   * @return accessCredentials
  **/
  @Schema(description = "Specifies a set of public keys to inject into the vm guest")
  public List<V1VmAccessCredential> getAccessCredentials() {
    return accessCredentials;
  }

  public void setAccessCredentials(List<V1VmAccessCredential> accessCredentials) {
    this.accessCredentials = accessCredentials;
  }

  public V1VmVirtualMachineInstanceSpec affinity(V1VmAffinity affinity) {
    this.affinity = affinity;
    return this;
  }

   /**
   * Get affinity
   * @return affinity
  **/
  @Schema(description = "")
  public V1VmAffinity getAffinity() {
    return affinity;
  }

  public void setAffinity(V1VmAffinity affinity) {
    this.affinity = affinity;
  }

  public V1VmVirtualMachineInstanceSpec dnsConfig(V1VmPodDnsConfig dnsConfig) {
    this.dnsConfig = dnsConfig;
    return this;
  }

   /**
   * Get dnsConfig
   * @return dnsConfig
  **/
  @Schema(description = "")
  public V1VmPodDnsConfig getDnsConfig() {
    return dnsConfig;
  }

  public void setDnsConfig(V1VmPodDnsConfig dnsConfig) {
    this.dnsConfig = dnsConfig;
  }

  public V1VmVirtualMachineInstanceSpec dnsPolicy(String dnsPolicy) {
    this.dnsPolicy = dnsPolicy;
    return this;
  }

   /**
   * Set DNS policy for the pod. Defaults to \&quot;ClusterFirst\&quot;. Valid values are &#x27;ClusterFirstWithHostNet&#x27;, &#x27;ClusterFirst&#x27;, &#x27;Default&#x27; or &#x27;None&#x27;. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to &#x27;ClusterFirstWithHostNet&#x27;.
   * @return dnsPolicy
  **/
  @Schema(description = "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.")
  public String getDnsPolicy() {
    return dnsPolicy;
  }

  public void setDnsPolicy(String dnsPolicy) {
    this.dnsPolicy = dnsPolicy;
  }

  public V1VmVirtualMachineInstanceSpec domain(V1VmDomainSpec domain) {
    this.domain = domain;
    return this;
  }

   /**
   * Get domain
   * @return domain
  **/
  @Schema(required = true, description = "")
  public V1VmDomainSpec getDomain() {
    return domain;
  }

  public void setDomain(V1VmDomainSpec domain) {
    this.domain = domain;
  }

  public V1VmVirtualMachineInstanceSpec evictionStrategy(String evictionStrategy) {
    this.evictionStrategy = evictionStrategy;
    return this;
  }

   /**
   * EvictionStrategy can be set to \&quot;LiveMigrate\&quot; if the VirtualMachineInstance should be migrated instead of shut-off in case of a node drain.
   * @return evictionStrategy
  **/
  @Schema(description = "EvictionStrategy can be set to \"LiveMigrate\" if the VirtualMachineInstance should be migrated instead of shut-off in case of a node drain.")
  public String getEvictionStrategy() {
    return evictionStrategy;
  }

  public void setEvictionStrategy(String evictionStrategy) {
    this.evictionStrategy = evictionStrategy;
  }

  public V1VmVirtualMachineInstanceSpec hostname(String hostname) {
    this.hostname = hostname;
    return this;
  }

   /**
   * Specifies the hostname of the vmi If not specified, the hostname will be set to the name of the vmi, if dhcp or cloud-init is configured properly.
   * @return hostname
  **/
  @Schema(description = "Specifies the hostname of the vmi If not specified, the hostname will be set to the name of the vmi, if dhcp or cloud-init is configured properly.")
  public String getHostname() {
    return hostname;
  }

  public void setHostname(String hostname) {
    this.hostname = hostname;
  }

  public V1VmVirtualMachineInstanceSpec livenessProbe(V1VmProbe livenessProbe) {
    this.livenessProbe = livenessProbe;
    return this;
  }

   /**
   * Get livenessProbe
   * @return livenessProbe
  **/
  @Schema(description = "")
  public V1VmProbe getLivenessProbe() {
    return livenessProbe;
  }

  public void setLivenessProbe(V1VmProbe livenessProbe) {
    this.livenessProbe = livenessProbe;
  }

  public V1VmVirtualMachineInstanceSpec networks(List<V1VmNetwork> networks) {
    this.networks = networks;
    return this;
  }

  public V1VmVirtualMachineInstanceSpec addNetworksItem(V1VmNetwork networksItem) {
    if (this.networks == null) {
      this.networks = new ArrayList<V1VmNetwork>();
    }
    this.networks.add(networksItem);
    return this;
  }

   /**
   * List of networks that can be attached to a vm&#x27;s virtual interface.
   * @return networks
  **/
  @Schema(description = "List of networks that can be attached to a vm's virtual interface.")
  public List<V1VmNetwork> getNetworks() {
    return networks;
  }

  public void setNetworks(List<V1VmNetwork> networks) {
    this.networks = networks;
  }

  public V1VmVirtualMachineInstanceSpec nodeSelector(Map<String, String> nodeSelector) {
    this.nodeSelector = nodeSelector;
    return this;
  }

  public V1VmVirtualMachineInstanceSpec putNodeSelectorItem(String key, String nodeSelectorItem) {
    if (this.nodeSelector == null) {
      this.nodeSelector = new HashMap<String, String>();
    }
    this.nodeSelector.put(key, nodeSelectorItem);
    return this;
  }

   /**
   * NodeSelector is a selector which must be true for the vmi to fit on a node. Selector which must match a node&#x27;s labels for the vmi to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   * @return nodeSelector
  **/
  @Schema(description = "NodeSelector is a selector which must be true for the vmi to fit on a node. Selector which must match a node's labels for the vmi to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/")
  public Map<String, String> getNodeSelector() {
    return nodeSelector;
  }

  public void setNodeSelector(Map<String, String> nodeSelector) {
    this.nodeSelector = nodeSelector;
  }

  public V1VmVirtualMachineInstanceSpec priorityClassName(String priorityClassName) {
    this.priorityClassName = priorityClassName;
    return this;
  }

   /**
   * If specified, indicates the pod&#x27;s priority. If not specified, the pod priority will be default or zero if there is no default.
   * @return priorityClassName
  **/
  @Schema(description = "If specified, indicates the pod's priority. If not specified, the pod priority will be default or zero if there is no default.")
  public String getPriorityClassName() {
    return priorityClassName;
  }

  public void setPriorityClassName(String priorityClassName) {
    this.priorityClassName = priorityClassName;
  }

  public V1VmVirtualMachineInstanceSpec readinessProbe(V1VmProbe readinessProbe) {
    this.readinessProbe = readinessProbe;
    return this;
  }

   /**
   * Get readinessProbe
   * @return readinessProbe
  **/
  @Schema(description = "")
  public V1VmProbe getReadinessProbe() {
    return readinessProbe;
  }

  public void setReadinessProbe(V1VmProbe readinessProbe) {
    this.readinessProbe = readinessProbe;
  }

  public V1VmVirtualMachineInstanceSpec schedulerName(String schedulerName) {
    this.schedulerName = schedulerName;
    return this;
  }

   /**
   * If specified, the VMI will be dispatched by specified scheduler. If not specified, the VMI will be dispatched by default scheduler.
   * @return schedulerName
  **/
  @Schema(description = "If specified, the VMI will be dispatched by specified scheduler. If not specified, the VMI will be dispatched by default scheduler.")
  public String getSchedulerName() {
    return schedulerName;
  }

  public void setSchedulerName(String schedulerName) {
    this.schedulerName = schedulerName;
  }

  public V1VmVirtualMachineInstanceSpec startStrategy(String startStrategy) {
    this.startStrategy = startStrategy;
    return this;
  }

   /**
   * StartStrategy can be set to \&quot;Paused\&quot; if Virtual Machine should be started in paused state.
   * @return startStrategy
  **/
  @Schema(description = "StartStrategy can be set to \"Paused\" if Virtual Machine should be started in paused state.")
  public String getStartStrategy() {
    return startStrategy;
  }

  public void setStartStrategy(String startStrategy) {
    this.startStrategy = startStrategy;
  }

  public V1VmVirtualMachineInstanceSpec subdomain(String subdomain) {
    this.subdomain = subdomain;
    return this;
  }

   /**
   * If specified, the fully qualified vmi hostname will be \&quot;&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;\&quot;. If not specified, the vmi will not have a domainname at all. The DNS entry will resolve to the vmi, no matter if the vmi itself can pick up a hostname.
   * @return subdomain
  **/
  @Schema(description = "If specified, the fully qualified vmi hostname will be \"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\". If not specified, the vmi will not have a domainname at all. The DNS entry will resolve to the vmi, no matter if the vmi itself can pick up a hostname.")
  public String getSubdomain() {
    return subdomain;
  }

  public void setSubdomain(String subdomain) {
    this.subdomain = subdomain;
  }

  public V1VmVirtualMachineInstanceSpec terminationGracePeriodSeconds(Long terminationGracePeriodSeconds) {
    this.terminationGracePeriodSeconds = terminationGracePeriodSeconds;
    return this;
  }

   /**
   * Grace period observed after signalling a VirtualMachineInstance to stop after which the VirtualMachineInstance is force terminated.
   * @return terminationGracePeriodSeconds
  **/
  @Schema(description = "Grace period observed after signalling a VirtualMachineInstance to stop after which the VirtualMachineInstance is force terminated.")
  public Long getTerminationGracePeriodSeconds() {
    return terminationGracePeriodSeconds;
  }

  public void setTerminationGracePeriodSeconds(Long terminationGracePeriodSeconds) {
    this.terminationGracePeriodSeconds = terminationGracePeriodSeconds;
  }

  public V1VmVirtualMachineInstanceSpec tolerations(List<V1VmToleration> tolerations) {
    this.tolerations = tolerations;
    return this;
  }

  public V1VmVirtualMachineInstanceSpec addTolerationsItem(V1VmToleration tolerationsItem) {
    if (this.tolerations == null) {
      this.tolerations = new ArrayList<V1VmToleration>();
    }
    this.tolerations.add(tolerationsItem);
    return this;
  }

   /**
   * If toleration is specified, obey all the toleration rules.
   * @return tolerations
  **/
  @Schema(description = "If toleration is specified, obey all the toleration rules.")
  public List<V1VmToleration> getTolerations() {
    return tolerations;
  }

  public void setTolerations(List<V1VmToleration> tolerations) {
    this.tolerations = tolerations;
  }

  public V1VmVirtualMachineInstanceSpec topologySpreadConstraints(List<V1VmTopologySpreadConstraint> topologySpreadConstraints) {
    this.topologySpreadConstraints = topologySpreadConstraints;
    return this;
  }

  public V1VmVirtualMachineInstanceSpec addTopologySpreadConstraintsItem(V1VmTopologySpreadConstraint topologySpreadConstraintsItem) {
    if (this.topologySpreadConstraints == null) {
      this.topologySpreadConstraints = new ArrayList<V1VmTopologySpreadConstraint>();
    }
    this.topologySpreadConstraints.add(topologySpreadConstraintsItem);
    return this;
  }

   /**
   * TopologySpreadConstraints describes how a group of VMIs will be spread across a given topology domains. K8s scheduler will schedule VMI pods in a way which abides by the constraints.
   * @return topologySpreadConstraints
  **/
  @Schema(description = "TopologySpreadConstraints describes how a group of VMIs will be spread across a given topology domains. K8s scheduler will schedule VMI pods in a way which abides by the constraints.")
  public List<V1VmTopologySpreadConstraint> getTopologySpreadConstraints() {
    return topologySpreadConstraints;
  }

  public void setTopologySpreadConstraints(List<V1VmTopologySpreadConstraint> topologySpreadConstraints) {
    this.topologySpreadConstraints = topologySpreadConstraints;
  }

  public V1VmVirtualMachineInstanceSpec volumes(List<V1VmVolume> volumes) {
    this.volumes = volumes;
    return this;
  }

  public V1VmVirtualMachineInstanceSpec addVolumesItem(V1VmVolume volumesItem) {
    if (this.volumes == null) {
      this.volumes = new ArrayList<V1VmVolume>();
    }
    this.volumes.add(volumesItem);
    return this;
  }

   /**
   * List of volumes that can be mounted by disks belonging to the vmi.
   * @return volumes
  **/
  @Schema(description = "List of volumes that can be mounted by disks belonging to the vmi.")
  public List<V1VmVolume> getVolumes() {
    return volumes;
  }

  public void setVolumes(List<V1VmVolume> volumes) {
    this.volumes = volumes;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1VmVirtualMachineInstanceSpec v1VmVirtualMachineInstanceSpec = (V1VmVirtualMachineInstanceSpec) o;
    return Objects.equals(this.accessCredentials, v1VmVirtualMachineInstanceSpec.accessCredentials) &&
        Objects.equals(this.affinity, v1VmVirtualMachineInstanceSpec.affinity) &&
        Objects.equals(this.dnsConfig, v1VmVirtualMachineInstanceSpec.dnsConfig) &&
        Objects.equals(this.dnsPolicy, v1VmVirtualMachineInstanceSpec.dnsPolicy) &&
        Objects.equals(this.domain, v1VmVirtualMachineInstanceSpec.domain) &&
        Objects.equals(this.evictionStrategy, v1VmVirtualMachineInstanceSpec.evictionStrategy) &&
        Objects.equals(this.hostname, v1VmVirtualMachineInstanceSpec.hostname) &&
        Objects.equals(this.livenessProbe, v1VmVirtualMachineInstanceSpec.livenessProbe) &&
        Objects.equals(this.networks, v1VmVirtualMachineInstanceSpec.networks) &&
        Objects.equals(this.nodeSelector, v1VmVirtualMachineInstanceSpec.nodeSelector) &&
        Objects.equals(this.priorityClassName, v1VmVirtualMachineInstanceSpec.priorityClassName) &&
        Objects.equals(this.readinessProbe, v1VmVirtualMachineInstanceSpec.readinessProbe) &&
        Objects.equals(this.schedulerName, v1VmVirtualMachineInstanceSpec.schedulerName) &&
        Objects.equals(this.startStrategy, v1VmVirtualMachineInstanceSpec.startStrategy) &&
        Objects.equals(this.subdomain, v1VmVirtualMachineInstanceSpec.subdomain) &&
        Objects.equals(this.terminationGracePeriodSeconds, v1VmVirtualMachineInstanceSpec.terminationGracePeriodSeconds) &&
        Objects.equals(this.tolerations, v1VmVirtualMachineInstanceSpec.tolerations) &&
        Objects.equals(this.topologySpreadConstraints, v1VmVirtualMachineInstanceSpec.topologySpreadConstraints) &&
        Objects.equals(this.volumes, v1VmVirtualMachineInstanceSpec.volumes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accessCredentials, affinity, dnsConfig, dnsPolicy, domain, evictionStrategy, hostname, livenessProbe, networks, nodeSelector, priorityClassName, readinessProbe, schedulerName, startStrategy, subdomain, terminationGracePeriodSeconds, tolerations, topologySpreadConstraints, volumes);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1VmVirtualMachineInstanceSpec {\n");
    
    sb.append("    accessCredentials: ").append(toIndentedString(accessCredentials)).append("\n");
    sb.append("    affinity: ").append(toIndentedString(affinity)).append("\n");
    sb.append("    dnsConfig: ").append(toIndentedString(dnsConfig)).append("\n");
    sb.append("    dnsPolicy: ").append(toIndentedString(dnsPolicy)).append("\n");
    sb.append("    domain: ").append(toIndentedString(domain)).append("\n");
    sb.append("    evictionStrategy: ").append(toIndentedString(evictionStrategy)).append("\n");
    sb.append("    hostname: ").append(toIndentedString(hostname)).append("\n");
    sb.append("    livenessProbe: ").append(toIndentedString(livenessProbe)).append("\n");
    sb.append("    networks: ").append(toIndentedString(networks)).append("\n");
    sb.append("    nodeSelector: ").append(toIndentedString(nodeSelector)).append("\n");
    sb.append("    priorityClassName: ").append(toIndentedString(priorityClassName)).append("\n");
    sb.append("    readinessProbe: ").append(toIndentedString(readinessProbe)).append("\n");
    sb.append("    schedulerName: ").append(toIndentedString(schedulerName)).append("\n");
    sb.append("    startStrategy: ").append(toIndentedString(startStrategy)).append("\n");
    sb.append("    subdomain: ").append(toIndentedString(subdomain)).append("\n");
    sb.append("    terminationGracePeriodSeconds: ").append(toIndentedString(terminationGracePeriodSeconds)).append("\n");
    sb.append("    tolerations: ").append(toIndentedString(tolerations)).append("\n");
    sb.append("    topologySpreadConstraints: ").append(toIndentedString(topologySpreadConstraints)).append("\n");
    sb.append("    volumes: ").append(toIndentedString(volumes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
