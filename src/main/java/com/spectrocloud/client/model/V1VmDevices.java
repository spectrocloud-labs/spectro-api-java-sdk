/*
 * Palette APIs - 3.4
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.spectrocloud.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.spectrocloud.client.model.V1VmClientPassthroughDevices;
import com.spectrocloud.client.model.V1VmDisk;
import com.spectrocloud.client.model.V1VmFilesystem;
import com.spectrocloud.client.model.V1VmGPU;
import com.spectrocloud.client.model.V1VmHostDevice;
import com.spectrocloud.client.model.V1VmInput;
import com.spectrocloud.client.model.V1VmInterface;
import com.spectrocloud.client.model.V1VmRng;
import com.spectrocloud.client.model.V1VmSoundDevice;
import com.spectrocloud.client.model.V1VmTPMDevice;
import com.spectrocloud.client.model.V1VmWatchdog;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * V1VmDevices
 */



public class V1VmDevices {
  @SerializedName("autoattachGraphicsDevice")
  private Boolean autoattachGraphicsDevice = null;

  @SerializedName("autoattachInputDevice")
  private Boolean autoattachInputDevice = null;

  @SerializedName("autoattachMemBalloon")
  private Boolean autoattachMemBalloon = null;

  @SerializedName("autoattachPodInterface")
  private Boolean autoattachPodInterface = null;

  @SerializedName("autoattachSerialConsole")
  private Boolean autoattachSerialConsole = null;

  @SerializedName("autoattachVSOCK")
  private Boolean autoattachVSOCK = null;

  @SerializedName("blockMultiQueue")
  private Boolean blockMultiQueue = null;

  @SerializedName("clientPassthrough")
  private V1VmClientPassthroughDevices clientPassthrough = null;

  @SerializedName("disableHotplug")
  private Boolean disableHotplug = null;

  @SerializedName("disks")
  private List<V1VmDisk> disks = null;

  @SerializedName("filesystems")
  private List<V1VmFilesystem> filesystems = null;

  @SerializedName("gpus")
  private List<V1VmGPU> gpus = null;

  @SerializedName("hostDevices")
  private List<V1VmHostDevice> hostDevices = null;

  @SerializedName("inputs")
  private List<V1VmInput> inputs = null;

  @SerializedName("interfaces")
  private List<V1VmInterface> interfaces = null;

  @SerializedName("networkInterfaceMultiqueue")
  private Boolean networkInterfaceMultiqueue = null;

  @SerializedName("rng")
  private V1VmRng rng = null;

  @SerializedName("sound")
  private V1VmSoundDevice sound = null;

  @SerializedName("tpm")
  private V1VmTPMDevice tpm = null;

  @SerializedName("useVirtioTransitional")
  private Boolean useVirtioTransitional = null;

  @SerializedName("watchdog")
  private V1VmWatchdog watchdog = null;

  public V1VmDevices autoattachGraphicsDevice(Boolean autoattachGraphicsDevice) {
    this.autoattachGraphicsDevice = autoattachGraphicsDevice;
    return this;
  }

   /**
   * Whether to attach the default graphics device or not. VNC will not be available if set to false. Defaults to true.
   * @return autoattachGraphicsDevice
  **/
  @Schema(description = "Whether to attach the default graphics device or not. VNC will not be available if set to false. Defaults to true.")
  public Boolean isAutoattachGraphicsDevice() {
    return autoattachGraphicsDevice;
  }

  public void setAutoattachGraphicsDevice(Boolean autoattachGraphicsDevice) {
    this.autoattachGraphicsDevice = autoattachGraphicsDevice;
  }

  public V1VmDevices autoattachInputDevice(Boolean autoattachInputDevice) {
    this.autoattachInputDevice = autoattachInputDevice;
    return this;
  }

   /**
   * Whether to attach an Input Device. Defaults to false.
   * @return autoattachInputDevice
  **/
  @Schema(description = "Whether to attach an Input Device. Defaults to false.")
  public Boolean isAutoattachInputDevice() {
    return autoattachInputDevice;
  }

  public void setAutoattachInputDevice(Boolean autoattachInputDevice) {
    this.autoattachInputDevice = autoattachInputDevice;
  }

  public V1VmDevices autoattachMemBalloon(Boolean autoattachMemBalloon) {
    this.autoattachMemBalloon = autoattachMemBalloon;
    return this;
  }

   /**
   * Whether to attach the Memory balloon device with default period. Period can be adjusted in virt-config. Defaults to true.
   * @return autoattachMemBalloon
  **/
  @Schema(description = "Whether to attach the Memory balloon device with default period. Period can be adjusted in virt-config. Defaults to true.")
  public Boolean isAutoattachMemBalloon() {
    return autoattachMemBalloon;
  }

  public void setAutoattachMemBalloon(Boolean autoattachMemBalloon) {
    this.autoattachMemBalloon = autoattachMemBalloon;
  }

  public V1VmDevices autoattachPodInterface(Boolean autoattachPodInterface) {
    this.autoattachPodInterface = autoattachPodInterface;
    return this;
  }

   /**
   * Whether to attach a pod network interface. Defaults to true.
   * @return autoattachPodInterface
  **/
  @Schema(description = "Whether to attach a pod network interface. Defaults to true.")
  public Boolean isAutoattachPodInterface() {
    return autoattachPodInterface;
  }

  public void setAutoattachPodInterface(Boolean autoattachPodInterface) {
    this.autoattachPodInterface = autoattachPodInterface;
  }

  public V1VmDevices autoattachSerialConsole(Boolean autoattachSerialConsole) {
    this.autoattachSerialConsole = autoattachSerialConsole;
    return this;
  }

   /**
   * Whether to attach the default serial console or not. Serial console access will not be available if set to false. Defaults to true.
   * @return autoattachSerialConsole
  **/
  @Schema(description = "Whether to attach the default serial console or not. Serial console access will not be available if set to false. Defaults to true.")
  public Boolean isAutoattachSerialConsole() {
    return autoattachSerialConsole;
  }

  public void setAutoattachSerialConsole(Boolean autoattachSerialConsole) {
    this.autoattachSerialConsole = autoattachSerialConsole;
  }

  public V1VmDevices autoattachVSOCK(Boolean autoattachVSOCK) {
    this.autoattachVSOCK = autoattachVSOCK;
    return this;
  }

   /**
   * Whether to attach the VSOCK CID to the VM or not. VSOCK access will be available if set to true. Defaults to false.
   * @return autoattachVSOCK
  **/
  @Schema(description = "Whether to attach the VSOCK CID to the VM or not. VSOCK access will be available if set to true. Defaults to false.")
  public Boolean isAutoattachVSOCK() {
    return autoattachVSOCK;
  }

  public void setAutoattachVSOCK(Boolean autoattachVSOCK) {
    this.autoattachVSOCK = autoattachVSOCK;
  }

  public V1VmDevices blockMultiQueue(Boolean blockMultiQueue) {
    this.blockMultiQueue = blockMultiQueue;
    return this;
  }

   /**
   * Whether or not to enable virtio multi-queue for block devices. Defaults to false.
   * @return blockMultiQueue
  **/
  @Schema(description = "Whether or not to enable virtio multi-queue for block devices. Defaults to false.")
  public Boolean isBlockMultiQueue() {
    return blockMultiQueue;
  }

  public void setBlockMultiQueue(Boolean blockMultiQueue) {
    this.blockMultiQueue = blockMultiQueue;
  }

  public V1VmDevices clientPassthrough(V1VmClientPassthroughDevices clientPassthrough) {
    this.clientPassthrough = clientPassthrough;
    return this;
  }

   /**
   * Get clientPassthrough
   * @return clientPassthrough
  **/
  @Schema(description = "")
  public V1VmClientPassthroughDevices getClientPassthrough() {
    return clientPassthrough;
  }

  public void setClientPassthrough(V1VmClientPassthroughDevices clientPassthrough) {
    this.clientPassthrough = clientPassthrough;
  }

  public V1VmDevices disableHotplug(Boolean disableHotplug) {
    this.disableHotplug = disableHotplug;
    return this;
  }

   /**
   * DisableHotplug disabled the ability to hotplug disks.
   * @return disableHotplug
  **/
  @Schema(description = "DisableHotplug disabled the ability to hotplug disks.")
  public Boolean isDisableHotplug() {
    return disableHotplug;
  }

  public void setDisableHotplug(Boolean disableHotplug) {
    this.disableHotplug = disableHotplug;
  }

  public V1VmDevices disks(List<V1VmDisk> disks) {
    this.disks = disks;
    return this;
  }

  public V1VmDevices addDisksItem(V1VmDisk disksItem) {
    if (this.disks == null) {
      this.disks = new ArrayList<V1VmDisk>();
    }
    this.disks.add(disksItem);
    return this;
  }

   /**
   * Disks describes disks, cdroms and luns which are connected to the vmi.
   * @return disks
  **/
  @Schema(description = "Disks describes disks, cdroms and luns which are connected to the vmi.")
  public List<V1VmDisk> getDisks() {
    return disks;
  }

  public void setDisks(List<V1VmDisk> disks) {
    this.disks = disks;
  }

  public V1VmDevices filesystems(List<V1VmFilesystem> filesystems) {
    this.filesystems = filesystems;
    return this;
  }

  public V1VmDevices addFilesystemsItem(V1VmFilesystem filesystemsItem) {
    if (this.filesystems == null) {
      this.filesystems = new ArrayList<V1VmFilesystem>();
    }
    this.filesystems.add(filesystemsItem);
    return this;
  }

   /**
   * Filesystems describes filesystem which is connected to the vmi.
   * @return filesystems
  **/
  @Schema(description = "Filesystems describes filesystem which is connected to the vmi.")
  public List<V1VmFilesystem> getFilesystems() {
    return filesystems;
  }

  public void setFilesystems(List<V1VmFilesystem> filesystems) {
    this.filesystems = filesystems;
  }

  public V1VmDevices gpus(List<V1VmGPU> gpus) {
    this.gpus = gpus;
    return this;
  }

  public V1VmDevices addGpusItem(V1VmGPU gpusItem) {
    if (this.gpus == null) {
      this.gpus = new ArrayList<V1VmGPU>();
    }
    this.gpus.add(gpusItem);
    return this;
  }

   /**
   * Whether to attach a GPU device to the vmi.
   * @return gpus
  **/
  @Schema(description = "Whether to attach a GPU device to the vmi.")
  public List<V1VmGPU> getGpus() {
    return gpus;
  }

  public void setGpus(List<V1VmGPU> gpus) {
    this.gpus = gpus;
  }

  public V1VmDevices hostDevices(List<V1VmHostDevice> hostDevices) {
    this.hostDevices = hostDevices;
    return this;
  }

  public V1VmDevices addHostDevicesItem(V1VmHostDevice hostDevicesItem) {
    if (this.hostDevices == null) {
      this.hostDevices = new ArrayList<V1VmHostDevice>();
    }
    this.hostDevices.add(hostDevicesItem);
    return this;
  }

   /**
   * Whether to attach a host device to the vmi.
   * @return hostDevices
  **/
  @Schema(description = "Whether to attach a host device to the vmi.")
  public List<V1VmHostDevice> getHostDevices() {
    return hostDevices;
  }

  public void setHostDevices(List<V1VmHostDevice> hostDevices) {
    this.hostDevices = hostDevices;
  }

  public V1VmDevices inputs(List<V1VmInput> inputs) {
    this.inputs = inputs;
    return this;
  }

  public V1VmDevices addInputsItem(V1VmInput inputsItem) {
    if (this.inputs == null) {
      this.inputs = new ArrayList<V1VmInput>();
    }
    this.inputs.add(inputsItem);
    return this;
  }

   /**
   * Inputs describe input devices
   * @return inputs
  **/
  @Schema(description = "Inputs describe input devices")
  public List<V1VmInput> getInputs() {
    return inputs;
  }

  public void setInputs(List<V1VmInput> inputs) {
    this.inputs = inputs;
  }

  public V1VmDevices interfaces(List<V1VmInterface> interfaces) {
    this.interfaces = interfaces;
    return this;
  }

  public V1VmDevices addInterfacesItem(V1VmInterface interfacesItem) {
    if (this.interfaces == null) {
      this.interfaces = new ArrayList<V1VmInterface>();
    }
    this.interfaces.add(interfacesItem);
    return this;
  }

   /**
   * Interfaces describe network interfaces which are added to the vmi.
   * @return interfaces
  **/
  @Schema(description = "Interfaces describe network interfaces which are added to the vmi.")
  public List<V1VmInterface> getInterfaces() {
    return interfaces;
  }

  public void setInterfaces(List<V1VmInterface> interfaces) {
    this.interfaces = interfaces;
  }

  public V1VmDevices networkInterfaceMultiqueue(Boolean networkInterfaceMultiqueue) {
    this.networkInterfaceMultiqueue = networkInterfaceMultiqueue;
    return this;
  }

   /**
   * If specified, virtual network interfaces configured with a virtio bus will also enable the vhost multiqueue feature for network devices. The number of queues created depends on additional factors of the VirtualMachineInstance, like the number of guest CPUs.
   * @return networkInterfaceMultiqueue
  **/
  @Schema(description = "If specified, virtual network interfaces configured with a virtio bus will also enable the vhost multiqueue feature for network devices. The number of queues created depends on additional factors of the VirtualMachineInstance, like the number of guest CPUs.")
  public Boolean isNetworkInterfaceMultiqueue() {
    return networkInterfaceMultiqueue;
  }

  public void setNetworkInterfaceMultiqueue(Boolean networkInterfaceMultiqueue) {
    this.networkInterfaceMultiqueue = networkInterfaceMultiqueue;
  }

  public V1VmDevices rng(V1VmRng rng) {
    this.rng = rng;
    return this;
  }

   /**
   * Get rng
   * @return rng
  **/
  @Schema(description = "")
  public V1VmRng getRng() {
    return rng;
  }

  public void setRng(V1VmRng rng) {
    this.rng = rng;
  }

  public V1VmDevices sound(V1VmSoundDevice sound) {
    this.sound = sound;
    return this;
  }

   /**
   * Get sound
   * @return sound
  **/
  @Schema(description = "")
  public V1VmSoundDevice getSound() {
    return sound;
  }

  public void setSound(V1VmSoundDevice sound) {
    this.sound = sound;
  }

  public V1VmDevices tpm(V1VmTPMDevice tpm) {
    this.tpm = tpm;
    return this;
  }

   /**
   * Get tpm
   * @return tpm
  **/
  @Schema(description = "")
  public V1VmTPMDevice getTpm() {
    return tpm;
  }

  public void setTpm(V1VmTPMDevice tpm) {
    this.tpm = tpm;
  }

  public V1VmDevices useVirtioTransitional(Boolean useVirtioTransitional) {
    this.useVirtioTransitional = useVirtioTransitional;
    return this;
  }

   /**
   * Fall back to legacy virtio 0.9 support if virtio bus is selected on devices. This is helpful for old machines like CentOS6 or RHEL6 which do not understand virtio_non_transitional (virtio 1.0).
   * @return useVirtioTransitional
  **/
  @Schema(description = "Fall back to legacy virtio 0.9 support if virtio bus is selected on devices. This is helpful for old machines like CentOS6 or RHEL6 which do not understand virtio_non_transitional (virtio 1.0).")
  public Boolean isUseVirtioTransitional() {
    return useVirtioTransitional;
  }

  public void setUseVirtioTransitional(Boolean useVirtioTransitional) {
    this.useVirtioTransitional = useVirtioTransitional;
  }

  public V1VmDevices watchdog(V1VmWatchdog watchdog) {
    this.watchdog = watchdog;
    return this;
  }

   /**
   * Get watchdog
   * @return watchdog
  **/
  @Schema(description = "")
  public V1VmWatchdog getWatchdog() {
    return watchdog;
  }

  public void setWatchdog(V1VmWatchdog watchdog) {
    this.watchdog = watchdog;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1VmDevices v1VmDevices = (V1VmDevices) o;
    return Objects.equals(this.autoattachGraphicsDevice, v1VmDevices.autoattachGraphicsDevice) &&
        Objects.equals(this.autoattachInputDevice, v1VmDevices.autoattachInputDevice) &&
        Objects.equals(this.autoattachMemBalloon, v1VmDevices.autoattachMemBalloon) &&
        Objects.equals(this.autoattachPodInterface, v1VmDevices.autoattachPodInterface) &&
        Objects.equals(this.autoattachSerialConsole, v1VmDevices.autoattachSerialConsole) &&
        Objects.equals(this.autoattachVSOCK, v1VmDevices.autoattachVSOCK) &&
        Objects.equals(this.blockMultiQueue, v1VmDevices.blockMultiQueue) &&
        Objects.equals(this.clientPassthrough, v1VmDevices.clientPassthrough) &&
        Objects.equals(this.disableHotplug, v1VmDevices.disableHotplug) &&
        Objects.equals(this.disks, v1VmDevices.disks) &&
        Objects.equals(this.filesystems, v1VmDevices.filesystems) &&
        Objects.equals(this.gpus, v1VmDevices.gpus) &&
        Objects.equals(this.hostDevices, v1VmDevices.hostDevices) &&
        Objects.equals(this.inputs, v1VmDevices.inputs) &&
        Objects.equals(this.interfaces, v1VmDevices.interfaces) &&
        Objects.equals(this.networkInterfaceMultiqueue, v1VmDevices.networkInterfaceMultiqueue) &&
        Objects.equals(this.rng, v1VmDevices.rng) &&
        Objects.equals(this.sound, v1VmDevices.sound) &&
        Objects.equals(this.tpm, v1VmDevices.tpm) &&
        Objects.equals(this.useVirtioTransitional, v1VmDevices.useVirtioTransitional) &&
        Objects.equals(this.watchdog, v1VmDevices.watchdog);
  }

  @Override
  public int hashCode() {
    return Objects.hash(autoattachGraphicsDevice, autoattachInputDevice, autoattachMemBalloon, autoattachPodInterface, autoattachSerialConsole, autoattachVSOCK, blockMultiQueue, clientPassthrough, disableHotplug, disks, filesystems, gpus, hostDevices, inputs, interfaces, networkInterfaceMultiqueue, rng, sound, tpm, useVirtioTransitional, watchdog);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1VmDevices {\n");
    
    sb.append("    autoattachGraphicsDevice: ").append(toIndentedString(autoattachGraphicsDevice)).append("\n");
    sb.append("    autoattachInputDevice: ").append(toIndentedString(autoattachInputDevice)).append("\n");
    sb.append("    autoattachMemBalloon: ").append(toIndentedString(autoattachMemBalloon)).append("\n");
    sb.append("    autoattachPodInterface: ").append(toIndentedString(autoattachPodInterface)).append("\n");
    sb.append("    autoattachSerialConsole: ").append(toIndentedString(autoattachSerialConsole)).append("\n");
    sb.append("    autoattachVSOCK: ").append(toIndentedString(autoattachVSOCK)).append("\n");
    sb.append("    blockMultiQueue: ").append(toIndentedString(blockMultiQueue)).append("\n");
    sb.append("    clientPassthrough: ").append(toIndentedString(clientPassthrough)).append("\n");
    sb.append("    disableHotplug: ").append(toIndentedString(disableHotplug)).append("\n");
    sb.append("    disks: ").append(toIndentedString(disks)).append("\n");
    sb.append("    filesystems: ").append(toIndentedString(filesystems)).append("\n");
    sb.append("    gpus: ").append(toIndentedString(gpus)).append("\n");
    sb.append("    hostDevices: ").append(toIndentedString(hostDevices)).append("\n");
    sb.append("    inputs: ").append(toIndentedString(inputs)).append("\n");
    sb.append("    interfaces: ").append(toIndentedString(interfaces)).append("\n");
    sb.append("    networkInterfaceMultiqueue: ").append(toIndentedString(networkInterfaceMultiqueue)).append("\n");
    sb.append("    rng: ").append(toIndentedString(rng)).append("\n");
    sb.append("    sound: ").append(toIndentedString(sound)).append("\n");
    sb.append("    tpm: ").append(toIndentedString(tpm)).append("\n");
    sb.append("    useVirtioTransitional: ").append(toIndentedString(useVirtioTransitional)).append("\n");
    sb.append("    watchdog: ").append(toIndentedString(watchdog)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
