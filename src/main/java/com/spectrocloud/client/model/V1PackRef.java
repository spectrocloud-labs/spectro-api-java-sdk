/*
 * Palette APIs - 3.4
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.spectrocloud.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.spectrocloud.client.model.V1ObjectReference;
import com.spectrocloud.client.model.V1PackPreset;
import com.spectrocloud.client.model.V1PackSchema;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * PackRef server/name:tag to point to a pack PackRef is used when construct a ClusterProfile PackSpec is used for UI to render the parameters form ClusterProfile will not know inner details of a pack ClusterProfile only contain pack name:tag, and the param values user entered for it
 */
@Schema(description = "PackRef server/name:tag to point to a pack PackRef is used when construct a ClusterProfile PackSpec is used for UI to render the parameters form ClusterProfile will not know inner details of a pack ClusterProfile only contain pack name:tag, and the param values user entered for it")


public class V1PackRef {
  @SerializedName("annotations")
  private Map<String, String> annotations = null;

  @SerializedName("digest")
  private String digest = null;

  @SerializedName("inValidReason")
  private String inValidReason = null;

  @SerializedName("isInvalid")
  private Boolean isInvalid = null;

  /**
   * Gets or Sets layer
   */
  @JsonAdapter(LayerEnum.Adapter.class)
  public enum LayerEnum {
    KERNEL("kernel"),
    OS("os"),
    K8S("k8s"),
    CNI("cni"),
    CSI("csi"),
    ADDON("addon");

    private String value;

    LayerEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static LayerEnum fromValue(String input) {
      for (LayerEnum b : LayerEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<LayerEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LayerEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public LayerEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return LayerEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("layer")
  private LayerEnum layer = null;

  @SerializedName("manifests")
  private List<V1ObjectReference> manifests = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("packUid")
  private String packUid = null;

  @SerializedName("params")
  private Map<String, String> params = null;

  @SerializedName("presets")
  private List<V1PackPreset> presets = null;

  @SerializedName("registryUid")
  private String registryUid = null;

  @SerializedName("schema")
  private List<V1PackSchema> schema = null;

  @SerializedName("server")
  private String server = null;

  @SerializedName("tag")
  private String tag = null;

  /**
   * type of the pack
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    SPECTRO("spectro"),
    HELM("helm"),
    MANIFEST("manifest");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TypeEnum fromValue(String input) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return TypeEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("type")
  private TypeEnum type = null;

  @SerializedName("values")
  private String values = null;

  @SerializedName("version")
  private String version = null;

  public V1PackRef annotations(Map<String, String> annotations) {
    this.annotations = annotations;
    return this;
  }

  public V1PackRef putAnnotationsItem(String key, String annotationsItem) {
    if (this.annotations == null) {
      this.annotations = new HashMap<String, String>();
    }
    this.annotations.put(key, annotationsItem);
    return this;
  }

   /**
   * Annotations is used to allow packref to add more arbitrary information one example is to add git reference for values.yaml
   * @return annotations
  **/
  @Schema(description = "Annotations is used to allow packref to add more arbitrary information one example is to add git reference for values.yaml")
  public Map<String, String> getAnnotations() {
    return annotations;
  }

  public void setAnnotations(Map<String, String> annotations) {
    this.annotations = annotations;
  }

  public V1PackRef digest(String digest) {
    this.digest = digest;
    return this;
  }

   /**
   * digest is used to specify the version should be installed by palette when pack upgrade available, change this digest to trigger upgrade
   * @return digest
  **/
  @Schema(description = "digest is used to specify the version should be installed by palette when pack upgrade available, change this digest to trigger upgrade")
  public String getDigest() {
    return digest;
  }

  public void setDigest(String digest) {
    this.digest = digest;
  }

  public V1PackRef inValidReason(String inValidReason) {
    this.inValidReason = inValidReason;
    return this;
  }

   /**
   * Get inValidReason
   * @return inValidReason
  **/
  @Schema(description = "")
  public String getInValidReason() {
    return inValidReason;
  }

  public void setInValidReason(String inValidReason) {
    this.inValidReason = inValidReason;
  }

  public V1PackRef isInvalid(Boolean isInvalid) {
    this.isInvalid = isInvalid;
    return this;
  }

   /**
   * pack is invalid when the associated tag is deleted from the registry
   * @return isInvalid
  **/
  @Schema(description = "pack is invalid when the associated tag is deleted from the registry")
  public Boolean isIsInvalid() {
    return isInvalid;
  }

  public void setIsInvalid(Boolean isInvalid) {
    this.isInvalid = isInvalid;
  }

  public V1PackRef layer(LayerEnum layer) {
    this.layer = layer;
    return this;
  }

   /**
   * Get layer
   * @return layer
  **/
  @Schema(required = true, description = "")
  public LayerEnum getLayer() {
    return layer;
  }

  public void setLayer(LayerEnum layer) {
    this.layer = layer;
  }

  public V1PackRef manifests(List<V1ObjectReference> manifests) {
    this.manifests = manifests;
    return this;
  }

  public V1PackRef addManifestsItem(V1ObjectReference manifestsItem) {
    if (this.manifests == null) {
      this.manifests = new ArrayList<V1ObjectReference>();
    }
    this.manifests.add(manifestsItem);
    return this;
  }

   /**
   * Get manifests
   * @return manifests
  **/
  @Schema(description = "")
  public List<V1ObjectReference> getManifests() {
    return manifests;
  }

  public void setManifests(List<V1ObjectReference> manifests) {
    this.manifests = manifests;
  }

  public V1PackRef name(String name) {
    this.name = name;
    return this;
  }

   /**
   * pack name
   * @return name
  **/
  @Schema(required = true, description = "pack name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public V1PackRef packUid(String packUid) {
    this.packUid = packUid;
    return this;
  }

   /**
   * PackUID is Hubble packUID, not palette Pack.UID It is used by Hubble only.
   * @return packUid
  **/
  @Schema(description = "PackUID is Hubble packUID, not palette Pack.UID It is used by Hubble only.")
  public String getPackUid() {
    return packUid;
  }

  public void setPackUid(String packUid) {
    this.packUid = packUid;
  }

  public V1PackRef params(Map<String, String> params) {
    this.params = params;
    return this;
  }

  public V1PackRef putParamsItem(String key, String paramsItem) {
    if (this.params == null) {
      this.params = new HashMap<String, String>();
    }
    this.params.put(key, paramsItem);
    return this;
  }

   /**
   * params passed as env variables to be consumed at installation time
   * @return params
  **/
  @Schema(description = "params passed as env variables to be consumed at installation time")
  public Map<String, String> getParams() {
    return params;
  }

  public void setParams(Map<String, String> params) {
    this.params = params;
  }

  public V1PackRef presets(List<V1PackPreset> presets) {
    this.presets = presets;
    return this;
  }

  public V1PackRef addPresetsItem(V1PackPreset presetsItem) {
    if (this.presets == null) {
      this.presets = new ArrayList<V1PackPreset>();
    }
    this.presets.add(presetsItem);
    return this;
  }

   /**
   * Get presets
   * @return presets
  **/
  @Schema(description = "")
  public List<V1PackPreset> getPresets() {
    return presets;
  }

  public void setPresets(List<V1PackPreset> presets) {
    this.presets = presets;
  }

  public V1PackRef registryUid(String registryUid) {
    this.registryUid = registryUid;
    return this;
  }

   /**
   * pack registry uid
   * @return registryUid
  **/
  @Schema(description = "pack registry uid")
  public String getRegistryUid() {
    return registryUid;
  }

  public void setRegistryUid(String registryUid) {
    this.registryUid = registryUid;
  }

  public V1PackRef schema(List<V1PackSchema> schema) {
    this.schema = schema;
    return this;
  }

  public V1PackRef addSchemaItem(V1PackSchema schemaItem) {
    if (this.schema == null) {
      this.schema = new ArrayList<V1PackSchema>();
    }
    this.schema.add(schemaItem);
    return this;
  }

   /**
   * Get schema
   * @return schema
  **/
  @Schema(description = "")
  public List<V1PackSchema> getSchema() {
    return schema;
  }

  public void setSchema(List<V1PackSchema> schema) {
    this.schema = schema;
  }

  public V1PackRef server(String server) {
    this.server = server;
    return this;
  }

   /**
   * pack registry server or helm repo
   * @return server
  **/
  @Schema(description = "pack registry server or helm repo")
  public String getServer() {
    return server;
  }

  public void setServer(String server) {
    this.server = server;
  }

  public V1PackRef tag(String tag) {
    this.tag = tag;
    return this;
  }

   /**
   * pack tag
   * @return tag
  **/
  @Schema(description = "pack tag")
  public String getTag() {
    return tag;
  }

  public void setTag(String tag) {
    this.tag = tag;
  }

  public V1PackRef type(TypeEnum type) {
    this.type = type;
    return this;
  }

   /**
   * type of the pack
   * @return type
  **/
  @Schema(description = "type of the pack")
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }

  public V1PackRef values(String values) {
    this.values = values;
    return this;
  }

   /**
   * values represents the values.yaml used as input parameters either Params OR Values should be used, not both If both applied at the same time, will only use Values
   * @return values
  **/
  @Schema(description = "values represents the values.yaml used as input parameters either Params OR Values should be used, not both If both applied at the same time, will only use Values")
  public String getValues() {
    return values;
  }

  public void setValues(String values) {
    this.values = values;
  }

  public V1PackRef version(String version) {
    this.version = version;
    return this;
  }

   /**
   * pack version
   * @return version
  **/
  @Schema(description = "pack version")
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1PackRef v1PackRef = (V1PackRef) o;
    return Objects.equals(this.annotations, v1PackRef.annotations) &&
        Objects.equals(this.digest, v1PackRef.digest) &&
        Objects.equals(this.inValidReason, v1PackRef.inValidReason) &&
        Objects.equals(this.isInvalid, v1PackRef.isInvalid) &&
        Objects.equals(this.layer, v1PackRef.layer) &&
        Objects.equals(this.manifests, v1PackRef.manifests) &&
        Objects.equals(this.name, v1PackRef.name) &&
        Objects.equals(this.packUid, v1PackRef.packUid) &&
        Objects.equals(this.params, v1PackRef.params) &&
        Objects.equals(this.presets, v1PackRef.presets) &&
        Objects.equals(this.registryUid, v1PackRef.registryUid) &&
        Objects.equals(this.schema, v1PackRef.schema) &&
        Objects.equals(this.server, v1PackRef.server) &&
        Objects.equals(this.tag, v1PackRef.tag) &&
        Objects.equals(this.type, v1PackRef.type) &&
        Objects.equals(this.values, v1PackRef.values) &&
        Objects.equals(this.version, v1PackRef.version);
  }

  @Override
  public int hashCode() {
    return Objects.hash(annotations, digest, inValidReason, isInvalid, layer, manifests, name, packUid, params, presets, registryUid, schema, server, tag, type, values, version);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1PackRef {\n");
    
    sb.append("    annotations: ").append(toIndentedString(annotations)).append("\n");
    sb.append("    digest: ").append(toIndentedString(digest)).append("\n");
    sb.append("    inValidReason: ").append(toIndentedString(inValidReason)).append("\n");
    sb.append("    isInvalid: ").append(toIndentedString(isInvalid)).append("\n");
    sb.append("    layer: ").append(toIndentedString(layer)).append("\n");
    sb.append("    manifests: ").append(toIndentedString(manifests)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    packUid: ").append(toIndentedString(packUid)).append("\n");
    sb.append("    params: ").append(toIndentedString(params)).append("\n");
    sb.append("    presets: ").append(toIndentedString(presets)).append("\n");
    sb.append("    registryUid: ").append(toIndentedString(registryUid)).append("\n");
    sb.append("    schema: ").append(toIndentedString(schema)).append("\n");
    sb.append("    server: ").append(toIndentedString(server)).append("\n");
    sb.append("    tag: ").append(toIndentedString(tag)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    values: ").append(toIndentedString(values)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
