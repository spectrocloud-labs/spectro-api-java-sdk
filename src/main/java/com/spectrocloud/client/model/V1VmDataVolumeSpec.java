/*
 * Palette APIs - 3.4
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.spectrocloud.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.spectrocloud.client.model.V1VmDataVolumeCheckpoint;
import com.spectrocloud.client.model.V1VmDataVolumeSource;
import com.spectrocloud.client.model.V1VmDataVolumeSourceRef;
import com.spectrocloud.client.model.V1VmPersistentVolumeClaimSpec;
import com.spectrocloud.client.model.V1VmStorageSpec;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * DataVolumeSpec defines the DataVolume type specification
 */
@Schema(description = "DataVolumeSpec defines the DataVolume type specification")


public class V1VmDataVolumeSpec {
  @SerializedName("checkpoints")
  private List<V1VmDataVolumeCheckpoint> checkpoints = null;

  @SerializedName("contentType")
  private String contentType = null;

  @SerializedName("finalCheckpoint")
  private Boolean finalCheckpoint = null;

  @SerializedName("preallocation")
  private Boolean preallocation = null;

  @SerializedName("priorityClassName")
  private String priorityClassName = null;

  @SerializedName("pvc")
  private V1VmPersistentVolumeClaimSpec pvc = null;

  @SerializedName("source")
  private V1VmDataVolumeSource source = null;

  @SerializedName("sourceRef")
  private V1VmDataVolumeSourceRef sourceRef = null;

  @SerializedName("storage")
  private V1VmStorageSpec storage = null;

  public V1VmDataVolumeSpec checkpoints(List<V1VmDataVolumeCheckpoint> checkpoints) {
    this.checkpoints = checkpoints;
    return this;
  }

  public V1VmDataVolumeSpec addCheckpointsItem(V1VmDataVolumeCheckpoint checkpointsItem) {
    if (this.checkpoints == null) {
      this.checkpoints = new ArrayList<V1VmDataVolumeCheckpoint>();
    }
    this.checkpoints.add(checkpointsItem);
    return this;
  }

   /**
   * Checkpoints is a list of DataVolumeCheckpoints, representing stages in a multistage import.
   * @return checkpoints
  **/
  @Schema(description = "Checkpoints is a list of DataVolumeCheckpoints, representing stages in a multistage import.")
  public List<V1VmDataVolumeCheckpoint> getCheckpoints() {
    return checkpoints;
  }

  public void setCheckpoints(List<V1VmDataVolumeCheckpoint> checkpoints) {
    this.checkpoints = checkpoints;
  }

  public V1VmDataVolumeSpec contentType(String contentType) {
    this.contentType = contentType;
    return this;
  }

   /**
   * DataVolumeContentType options: \&quot;kubevirt\&quot;, \&quot;archive\&quot;
   * @return contentType
  **/
  @Schema(description = "DataVolumeContentType options: \"kubevirt\", \"archive\"")
  public String getContentType() {
    return contentType;
  }

  public void setContentType(String contentType) {
    this.contentType = contentType;
  }

  public V1VmDataVolumeSpec finalCheckpoint(Boolean finalCheckpoint) {
    this.finalCheckpoint = finalCheckpoint;
    return this;
  }

   /**
   * FinalCheckpoint indicates whether the current DataVolumeCheckpoint is the final checkpoint.
   * @return finalCheckpoint
  **/
  @Schema(description = "FinalCheckpoint indicates whether the current DataVolumeCheckpoint is the final checkpoint.")
  public Boolean isFinalCheckpoint() {
    return finalCheckpoint;
  }

  public void setFinalCheckpoint(Boolean finalCheckpoint) {
    this.finalCheckpoint = finalCheckpoint;
  }

  public V1VmDataVolumeSpec preallocation(Boolean preallocation) {
    this.preallocation = preallocation;
    return this;
  }

   /**
   * Preallocation controls whether storage for DataVolumes should be allocated in advance.
   * @return preallocation
  **/
  @Schema(description = "Preallocation controls whether storage for DataVolumes should be allocated in advance.")
  public Boolean isPreallocation() {
    return preallocation;
  }

  public void setPreallocation(Boolean preallocation) {
    this.preallocation = preallocation;
  }

  public V1VmDataVolumeSpec priorityClassName(String priorityClassName) {
    this.priorityClassName = priorityClassName;
    return this;
  }

   /**
   * PriorityClassName for Importer, Cloner and Uploader pod
   * @return priorityClassName
  **/
  @Schema(description = "PriorityClassName for Importer, Cloner and Uploader pod")
  public String getPriorityClassName() {
    return priorityClassName;
  }

  public void setPriorityClassName(String priorityClassName) {
    this.priorityClassName = priorityClassName;
  }

  public V1VmDataVolumeSpec pvc(V1VmPersistentVolumeClaimSpec pvc) {
    this.pvc = pvc;
    return this;
  }

   /**
   * Get pvc
   * @return pvc
  **/
  @Schema(description = "")
  public V1VmPersistentVolumeClaimSpec getPvc() {
    return pvc;
  }

  public void setPvc(V1VmPersistentVolumeClaimSpec pvc) {
    this.pvc = pvc;
  }

  public V1VmDataVolumeSpec source(V1VmDataVolumeSource source) {
    this.source = source;
    return this;
  }

   /**
   * Get source
   * @return source
  **/
  @Schema(description = "")
  public V1VmDataVolumeSource getSource() {
    return source;
  }

  public void setSource(V1VmDataVolumeSource source) {
    this.source = source;
  }

  public V1VmDataVolumeSpec sourceRef(V1VmDataVolumeSourceRef sourceRef) {
    this.sourceRef = sourceRef;
    return this;
  }

   /**
   * Get sourceRef
   * @return sourceRef
  **/
  @Schema(description = "")
  public V1VmDataVolumeSourceRef getSourceRef() {
    return sourceRef;
  }

  public void setSourceRef(V1VmDataVolumeSourceRef sourceRef) {
    this.sourceRef = sourceRef;
  }

  public V1VmDataVolumeSpec storage(V1VmStorageSpec storage) {
    this.storage = storage;
    return this;
  }

   /**
   * Get storage
   * @return storage
  **/
  @Schema(description = "")
  public V1VmStorageSpec getStorage() {
    return storage;
  }

  public void setStorage(V1VmStorageSpec storage) {
    this.storage = storage;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1VmDataVolumeSpec v1VmDataVolumeSpec = (V1VmDataVolumeSpec) o;
    return Objects.equals(this.checkpoints, v1VmDataVolumeSpec.checkpoints) &&
        Objects.equals(this.contentType, v1VmDataVolumeSpec.contentType) &&
        Objects.equals(this.finalCheckpoint, v1VmDataVolumeSpec.finalCheckpoint) &&
        Objects.equals(this.preallocation, v1VmDataVolumeSpec.preallocation) &&
        Objects.equals(this.priorityClassName, v1VmDataVolumeSpec.priorityClassName) &&
        Objects.equals(this.pvc, v1VmDataVolumeSpec.pvc) &&
        Objects.equals(this.source, v1VmDataVolumeSpec.source) &&
        Objects.equals(this.sourceRef, v1VmDataVolumeSpec.sourceRef) &&
        Objects.equals(this.storage, v1VmDataVolumeSpec.storage);
  }

  @Override
  public int hashCode() {
    return Objects.hash(checkpoints, contentType, finalCheckpoint, preallocation, priorityClassName, pvc, source, sourceRef, storage);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1VmDataVolumeSpec {\n");
    
    sb.append("    checkpoints: ").append(toIndentedString(checkpoints)).append("\n");
    sb.append("    contentType: ").append(toIndentedString(contentType)).append("\n");
    sb.append("    finalCheckpoint: ").append(toIndentedString(finalCheckpoint)).append("\n");
    sb.append("    preallocation: ").append(toIndentedString(preallocation)).append("\n");
    sb.append("    priorityClassName: ").append(toIndentedString(priorityClassName)).append("\n");
    sb.append("    pvc: ").append(toIndentedString(pvc)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    sourceRef: ").append(toIndentedString(sourceRef)).append("\n");
    sb.append("    storage: ").append(toIndentedString(storage)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
